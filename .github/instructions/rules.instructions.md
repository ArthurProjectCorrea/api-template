---
applyTo: '**'
---

# Project Rules

This document defines mandatory rules that all contributors and automation tools MUST follow when creating, generating, or modifying files in this repository. These rules ensure code quality, consistency, and maintainability across the project.

---

## Rule 1 — Mandatory Usage of the Nest CLI for Generated Files

Any file that corresponds to a Nest CLI schematic MUST be generated using the Nest CLI from the terminal. Examples of schematics include: application, class, controller, decorator, filter, gateway, guard, interceptor, interface, library, middleware, module, pipe, provider, resolver, resource, service, sub-app, and others listed by `nest --help`.

### Why this rule exists

- The Nest CLI generates files with correct decorators, imports and structure, reducing manual errors and keeping code consistent across the project.
- Ensures proper integration with NestJS dependency injection and module system.
- Maintains standardized file naming and organization conventions.

### How to apply (examples)

From the repository root (PowerShell on Windows):

```powershell
nest generate controller users    # or: nest g co users
nest generate service users       # or: nest g s users
nest generate module users        # or: nest g mo users
nest generate resource users      # or: nest g res users
```

### Enforcement and exceptions

- ✅ **REQUIRED**: Use Nest CLI for all controller, service, module, guard, interceptor, pipe, filter, middleware, and gateway files.
- ❌ **NEVER**: Create manually (copy/paste/new file) a file that matches any Nest schematic without running the CLI first.
- ✅ **ALLOWED**: Edit generated files after creation to add custom logic.
- ✅ **EXCEPTIONS**: Configuration files, documentation, assets, SQL files, build scripts, or other files not present in the Nest schematics list may be created manually.

### Code review and CI

- Code reviewers and CI should check whether schematic-like files were generated by the Nest CLI when possible.
- If a schematic-like file was created manually, the PR author MUST justify the reason in the PR description.

### Notes

- Short aliases (e.g., `g`, `co`, `s`, `mo`) are supported by the Nest CLI — use them for faster workflow.
- It is fine to edit generated files after creation, but generation must not be skipped.

---

## Rule 2 — Error Correction and Validation

Whenever an error is identified in the codebase, it MUST be corrected and validated before providing feedback about the correction. This ensures that the issue is fully resolved and prevents unnecessary iterations.

### Why this rule exists

- To maintain high code quality and reliability.
- To reduce the time spent on rework and ensure that fixes are effective.
- To build trust in the development process by ensuring that reported fixes are verified.
- To prevent cascading errors and broken builds.

### How to apply

1. **Identify the error** in the codebase (e.g., test failure, linting issue, runtime error).
2. **Implement the necessary fix** in the code.
3. **Validate the fix** by:
   - Running the relevant tests to ensure they pass: `pnpm test`
   - Verifying that the issue no longer occurs in the application.
   - Checking for any side effects introduced by the fix.
   - Running linting: `pnpm run lint`
   - Running formatting: `pnpm run format`
4. **Provide feedback** about the correction only after the validation is complete.

### Enforcement and exceptions

- ✅ **REQUIRED**: Feedback about a correction MUST include evidence of validation (e.g., test results, logs).
- ❌ **NEVER**: Report a fix as complete without validating it.
- ✅ **EXCEPTIONS**: None. All identified errors must follow this process.

### Code review and CI

- Code reviewers and CI should verify that fixes are validated before merging.
- Automated tools should be configured to block unvalidated fixes from being merged.

---

## Rule 3 — Formatting Corrections

To ensure consistent code formatting across the project, contributors and automation tools MUST run the formatting command to fix formatting issues before committing changes.

### Why this rule exists

- To maintain a consistent code style throughout the project.
- To reduce unnecessary diffs caused by formatting inconsistencies.
- To ensure that all contributors adhere to the same formatting standards.
- To prevent merge conflicts caused by formatting differences.

### How to apply

Before committing any changes, run the following command from the repository root:

```powershell
pnpm format
```

Verify that no formatting issues remain by checking the output of the command.

### Enforcement and exceptions

- ✅ **REQUIRED**: Run `pnpm format` before every commit.
- ✅ **AUTOMATED**: Husky + lint-staged automatically format files on commit.
- ❌ **NEVER**: Commit code with formatting issues.
- ✅ **EXCEPTIONS**: None. All changes must follow this rule.

### Code review and CI

- Automated tools block commits or merges if formatting issues are detected.
- Pre-commit hooks enforce formatting automatically.

---

## Rule 4 — Language Standardization

All code, comments, documentation, commit messages, and user-facing text MUST be written in **technical English** by default.

### Why this rule exists

- Ensures consistency and readability across the entire codebase.
- Facilitates collaboration with international teams and open-source communities.
- Improves AI coding assistant comprehension and suggestions.
- Makes the project accessible to a wider audience of developers.

### How to apply

- ✅ **REQUIRED**: Use English for:
  - Variable names, function names, class names
  - Comments and inline documentation
  - Commit messages (following Conventional Commits)
  - README, documentation files, API documentation
  - Error messages, logs, and user-facing text
  - Test descriptions and test case names
- ✅ **ALLOWED**: Use another language only if explicitly requested by project stakeholders.
- ✅ **REQUIRED**: Use consistent technical terminology across the entire project.

### Enforcement and exceptions

- ❌ **NEVER**: Mix languages in the same file or context.
- ✅ **EXCEPTIONS**: Localization files (i18n) for multi-language support may contain non-English text.

---

## Rule 5 — Code Quality and Readability

All code MUST follow clean code principles and maintain high readability standards.

### Why this rule exists

- Improves maintainability and reduces technical debt.
- Makes code easier to understand, debug, and extend.
- Reduces onboarding time for new developers.
- Prevents bugs and facilitates code reviews.

### How to apply

#### Clean Code Principles

- ✅ **SOLID**: Follow Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.
- ✅ **DRY**: Don't Repeat Yourself - extract reusable logic into functions/services.
- ✅ **KISS**: Keep It Simple, Stupid - prefer simple solutions over complex ones.
- ✅ **Separation of Concerns**: Controllers handle HTTP, Services handle business logic, Repositories handle data access.

#### Naming Conventions

- ✅ **REQUIRED**: Use meaningful, descriptive, and consistent names.
  - Variables: `camelCase` (e.g., `userData`, `isAuthenticated`)
  - Functions/Methods: `camelCase` (e.g., `getUserById`, `validateToken`)
  - Classes/Interfaces: `PascalCase` (e.g., `UserService`, `AuthGuard`)
  - Constants: `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`, `API_VERSION`)
  - Files: `kebab-case` (e.g., `user.service.ts`, `auth.guard.ts`)

#### Function/Module Design

- ✅ **REQUIRED**: Keep functions small, cohesive, and focused on a single responsibility.
- ✅ **REQUIRED**: Functions should do one thing and do it well.
- ❌ **AVOID**: Functions longer than 50 lines (consider refactoring).
- ❌ **AVOID**: Functions with more than 3-4 parameters (consider using objects).

#### Code Clarity

- ✅ **REQUIRED**: Prefer explicitness over clever tricks; clarity is more important than brevity.
- ❌ **AVOID**: Magic numbers and hard-coded values; use constants or configuration files.
- ❌ **AVOID**: Deep nesting (max 3 levels); extract to functions if needed.

### Enforcement and exceptions

- Code reviews should reject code that violates these principles.
- ESLint and TypeScript compiler enforce many of these rules automatically.

---

## Rule 6 — Documentation Standards

All features, modules, and architectural decisions MUST be documented.

### Why this rule exists

- Ensures knowledge is preserved and accessible to all team members.
- Reduces dependency on individual developers.
- Facilitates onboarding and knowledge transfer.
- Improves code maintainability and debugging.

### How to apply

#### Project Documentation

- ✅ **REQUIRED**: Keep `README.md` up-to-date with setup instructions and main commands.
- ✅ **REQUIRED**: Organize documentation in `docs/public/` (external) and `docs/private/` (internal).
- ✅ **REQUIRED**: Document all API endpoints, request/response formats, and authentication in `docs/public/`.
- ✅ **REQUIRED**: Document architecture, workflows, and configuration in `docs/private/`.

#### Code Comments

- ✅ **REQUIRED**: Write comments only when the intent of code is not obvious.
- ✅ **FOCUS**: Comments should explain **why**, not **what**.
- ❌ **AVOID**: Obvious comments like `// increment i` for `i++`.
- ✅ **REQUIRED**: Document complex algorithms, business rules, and non-obvious decisions.

#### Examples

- ✅ **REQUIRED**: Provide examples where necessary to reduce ambiguity.
- ✅ **REQUIRED**: Include usage examples in API documentation.

### Enforcement and exceptions

- Code reviews should verify that new features include appropriate documentation.
- Missing documentation should block PR approval.

---

## Rule 7 — Testing Requirements

All critical logic MUST have automated tests.

### Why this rule exists

- Prevents regressions and catches bugs early.
- Provides confidence when refactoring code.
- Serves as living documentation of expected behavior.
- Enables safe continuous integration and deployment.

### How to apply

#### Test Coverage

- ✅ **REQUIRED**: Write unit tests for all services, guards, interceptors, and pipes.
- ✅ **REQUIRED**: Write E2E tests for all API endpoints.
- ✅ **TARGET**: Maintain minimum 80% code coverage.
- ✅ **FOCUS**: Prioritize testing critical business logic and edge cases.

#### Test Quality

- ✅ **REQUIRED**: Write tests in English with descriptive test case names.
- ✅ **REQUIRED**: Use AAA pattern (Arrange, Act, Assert).
- ✅ **REQUIRED**: Tests should be independent and repeatable.
- ❌ **AVOID**: Tests that depend on external services (use mocks).

#### Test Execution

- ✅ **REQUIRED**: Run tests before committing: `pnpm test`
- ✅ **REQUIRED**: All tests must pass before merging.
- ✅ **AUTOMATED**: CI/CD runs tests on every push and PR.

### Enforcement and exceptions

- PRs with failing tests will be automatically rejected.
- New features without tests should not be approved.
- ✅ **EXCEPTIONS**: Prototype/experimental branches (must be documented).

---

## Rule 8 — Version Control and Commit Standards

All commits MUST follow Conventional Commits specification and project branching strategy.

### Why this rule exists

- Enables automated versioning and changelog generation via Semantic Release.
- Provides clear, searchable commit history.
- Facilitates code review and debugging.
- Ensures consistent collaboration practices.

### How to apply

#### Commit Messages

- ✅ **REQUIRED**: Follow Conventional Commits format: `type(scope): subject`
- ✅ **REQUIRED**: Use Commitizen for interactive commit creation: `pnpm run commit`
- ✅ **AUTOMATED**: Commitlint validates commit messages on commit.
- ✅ **REFERENCE**: See `.github/instructions/commit.instructions.md` for full details.

#### Commit Practices

- ✅ **REQUIRED**: Commit often with clear and descriptive messages.
- ✅ **REQUIRED**: Keep commits small, isolated, and logically grouped.
- ✅ **REQUIRED**: One logical change per commit.
- ❌ **NEVER**: Mix unrelated changes in the same commit.

#### Branching Strategy

- ✅ **REQUIRED**: Follow Gitflow or trunk-based development strategy.
- ✅ **MAIN BRANCH**: `main` - production-ready code only.
- ✅ **DEVELOP BRANCH**: `develop` - integration branch for features.
- ✅ **FEATURE BRANCHES**: `feature/<name>` - new features.
- ✅ **BUGFIX BRANCHES**: `bugfix/<name>` - bug fixes.
- ✅ **HOTFIX BRANCHES**: `hotfix/<name>` - urgent production fixes.

### Enforcement and exceptions

- Commitlint rejects improperly formatted commits.
- PRs with bad commit history should be squashed or rebased.

---

## Rule 9 — Security and Reliability

All code MUST follow security best practices and handle errors properly.

### Why this rule exists

- Protects sensitive data and prevents security vulnerabilities.
- Ensures application reliability and stability.
- Builds trust with users and stakeholders.
- Complies with industry standards and regulations.

### How to apply

#### Security Practices

- ❌ **NEVER**: Commit secrets, credentials, API keys, or sensitive data.
- ✅ **REQUIRED**: Use environment variables for configuration (`.env` files).
- ✅ **REQUIRED**: Add `.env` to `.gitignore`.
- ✅ **REQUIRED**: Validate and sanitize all external inputs (APIs, user input, files).
- ✅ **REQUIRED**: Use parameterized queries to prevent SQL injection.
- ✅ **REQUIRED**: Implement proper authentication and authorization.
- ✅ **REQUIRED**: Keep dependencies up-to-date and review for vulnerabilities: `pnpm audit`

#### Error Handling

- ✅ **REQUIRED**: Always validate inputs and handle edge cases.
- ✅ **REQUIRED**: Use try-catch blocks for error-prone operations.
- ✅ **REQUIRED**: Use NestJS exception filters for consistent error responses.
- ✅ **REQUIRED**: Log errors appropriately (use Logger service).
- ❌ **NEVER**: Expose stack traces or sensitive information in error responses.

#### Defensive Programming

- ✅ **REQUIRED**: Use defensive programming techniques to avoid unexpected crashes.
- ✅ **REQUIRED**: Write code with scalability and maintainability in mind.
- ❌ **AVOID**: Quick fixes that introduce technical debt.

### Enforcement and exceptions

- Code reviews should verify security best practices.
- CI/CD should include security scanning tools.
- Dependencies with known vulnerabilities should block builds.

---

## Rule 10 — Performance and Scalability

Code MUST be written with performance and scalability considerations.

### Why this rule exists

- Ensures the application can handle growth and increased load.
- Provides a good user experience with fast response times.
- Reduces infrastructure costs by optimizing resource usage.

### How to apply

#### Performance Best Practices

- ✅ **REQUIRED**: Avoid premature optimization; focus on correctness and clarity first.
- ✅ **REQUIRED**: When performance is necessary, measure and profile before optimizing.
- ✅ **REQUIRED**: Use caching where appropriate (Redis, in-memory cache).
- ✅ **REQUIRED**: Optimize database queries (use indexes, limit results).
- ❌ **AVOID**: N+1 query problems (use joins or eager loading).
- ❌ **AVOID**: Blocking operations in critical paths (use async/await).

#### Scalability Design

- ✅ **REQUIRED**: Design with scalability in mind from the start.
- ✅ **REQUIRED**: Use stateless services for horizontal scaling.
- ✅ **REQUIRED**: Implement rate limiting and throttling for public APIs.
- ✅ **REQUIRED**: Use pagination for large data sets.

### Enforcement and exceptions

- Performance tests should be part of the CI/CD pipeline.
- Code reviews should identify performance bottlenecks.

---

## Rule 11 — Consistency and Standardization

All code MUST follow consistent conventions and use automated tooling.

### Why this rule exists

- Reduces cognitive overhead when reading code.
- Facilitates team collaboration and code reviews.
- Prevents style debates and bikeshedding.
- Enables automation and tooling integration.

### How to apply

#### Automated Tooling

- ✅ **REQUIRED**: Use ESLint for code quality: `pnpm run lint`
- ✅ **REQUIRED**: Use Prettier for formatting: `pnpm run format`
- ✅ **AUTOMATED**: Husky + lint-staged enforce quality on commit.
- ✅ **REQUIRED**: Fix all linting errors before committing.

#### Configuration Management

- ✅ **REQUIRED**: Centralize configuration in `.env` files.
- ✅ **REQUIRED**: Use `@nestjs/config` module for configuration management.
- ❌ **NEVER**: Hard-code configuration values in source code.

#### Convention Adherence

- ✅ **REQUIRED**: Apply the same conventions across the entire codebase.
- ✅ **REQUIRED**: Follow NestJS best practices and architectural patterns.
- ✅ **REQUIRED**: Use dependency injection instead of direct instantiation.

### Enforcement and exceptions

- Automated tools block commits with linting or formatting errors.
- Code reviews enforce consistency.

---

## Rule 12 — Continuous Improvement

The codebase MUST be continuously improved and maintained.

### Why this rule exists

- Prevents technical debt accumulation.
- Keeps the codebase modern and maintainable.
- Improves team productivity and code quality over time.
- Adapts to changing requirements and technologies.

### How to apply

#### Refactoring

- ✅ **REQUIRED**: Refactor when necessary to improve code quality.
- ✅ **REQUIRED**: Always question whether the current solution is the most maintainable.
- ❌ **AVOID**: Unnecessary refactoring that doesn't add value.
- ✅ **REQUIRED**: Include tests when refactoring to prevent regressions.

#### Learning and Adaptation

- ✅ **REQUIRED**: Learn from mistakes and update practices accordingly.
- ✅ **REQUIRED**: Document lessons learned in project knowledge base.
- ✅ **REQUIRED**: Keep up-to-date with NestJS updates and best practices.
- ✅ **REQUIRED**: Review and update dependencies regularly.

#### Code Reviews

- ✅ **REQUIRED**: Review and refactor code regularly to maintain quality.
- ✅ **REQUIRED**: Provide constructive feedback in code reviews.
- ✅ **REQUIRED**: Address code review comments before merging.

### Enforcement and exceptions

- Regular code quality audits should be scheduled.
- Technical debt should be tracked and prioritized.

---

## Summary

These rules are **mandatory** and apply to all contributors, including AI coding agents, automation tools, and human developers. Violations should be addressed immediately in code reviews and blocked by automated tooling where possible.

**Remember**: These rules exist to maintain code quality, consistency, and maintainability. Following them ensures a healthy, scalable, and reliable codebase. 🎯
